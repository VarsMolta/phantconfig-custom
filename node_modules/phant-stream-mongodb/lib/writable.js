/**
 * phant-stream-mongodb
 * https://github.com/sparkfun/phant-stream-mongodb
 *
 * Copyright (c) 2014 SparkFun Electronics
 * Licensed under the GPL v3 license.
 */

'use strict';

/**** Module dependencies ****/
var stream = require('stream'),
    util = require('util'),
    Promise = require('bluebird'),
    binstruct = require('binstruct');

/**** Make Writable a writable stream ****/
util.inherits(Writable, stream.Writable);

/**** Writable prototype ****/
var proto = Writable.prototype;

/**** Expose Writable ****/
exports = module.exports = Writable;

/**** Initialize a new Writable ****/
function Writable(config) {

  if (! (this instanceof Writable)) {
    return new Writable(config);
  }

  stream.Writable.call(this, {
    objectMode: true
  });

  // apply the options
  util._extend(this, config || {});

  this.setMaxListeners(0);

  this.init();

}

proto.id = false;
proto.mongo = false;
proto.collection = false;
//proto.collection = "544e9ca6a8b94bc155001c3b";
proto.loading = false;
proto.cap = false;
proto.db = false;

proto.init = function() {
 console.log("Init Writable");
  this.mongo.connect()
    .then(this.loadCollection.bind(this))
    .catch(this.handleError.bind(this));
};

proto.loadCollection = function(db) {

  var self = this;

  return new Promise(function(resolve, reject) {
	console.log("Entering Promise");
      console.log(self.collection);
    if(self.collection) {
      return resolve(self.collection);
    }
    console.log("Past collection promise");

    db.collection(self.id, {strict:true}, function(err, col) {
    console.log("YYY1");

      if(err) {

	console.log("Loading");
      console.log(self.loading);
        if(self.loading) {

          // reject this promise if loading throws an error
          self.once('error', reject);

          // listen for loaded event, and resolve promise
          self.once('loaded', function(col) {
            resolve(col);
          });

          return;

        }

	console.log("Past Loading");
        var options = {
          capped: false,
          strict: true
        };

        if(self.cap) {
          options.capped = true;
          options.size = self.cap;
        }

       self.loading = true;
        //db.collection(self.id, {strict:true}, function(err, col) {}
	//console.log("Enter collection");
        //if(err) {

        // create collection if it doesn't exist
        return db.createCollection(self.id, options, function(err, col) {

          if(err) {
            self.emit('error', err);
            return reject(err);
          }

          self.collection = col;
          self.loading = false;
          self.emit('loaded', col);
    	  console.log("Resolving promise");
          resolve(col);

        });

      }

   	console.log("Resolving promise2");
      // we have a collection, resolve promise

      self.collection = col;	
      resolve(col);
      //console.log(self.collection);
      //console.log(resolve(col));

    });
    //}.bind(this));

    console.log("Past collection promise3");
  });

};

proto._write = function(data, encoding, cb) {
  //var self = this;
  console.log("BUSY XXX BUSY");
  this.mongo.connect()
    .then(this.loadCollection.bind(this))
    .then(function(col) { 
      // log data
  
 	var headerData = data.readUInt32BE(0);
	var sensorLengthData = headerData & 0xFFFF;
	var packetSeq = (headerData >> 16) & 0xF;
 	var timeStamp = data.readDoubleBE(4);
	console.log(headerData);
	console.log(packetSeq);
  	console.log(sensorLengthData);
  	console.log(timeStamp);
  	//var sensorLength = 20;
	console.log("BUSY3");
	var inserted = 0;

//	console.log("BUSY2");
  //    console.log(data["Sensor Data"][i]["Accelerometer"][0]);
      //col.insert(data["Sensor Data"][i]["Accelerometer"][0], function(err) {;

  //for (var i = 12; i < sensorLengthData*4*3 + 12;i+=3*4) {	
  for (var i = 12; i < sensorLengthData*4*6 + 12;i+=6*4) {	

	var bulk = col.initializeUnorderedBulkOp();
	//bulk.insert(data["Sensor Data"][i]["Accelerometer"][0]);
	//bulk.insert(data["Sensor Data"][i]);
	//bulk.insert({x: data.readFloatBE(i), y: data.readFloatBE(i+4), z: data.readFloatBE(i+8)}); //WORKING ACCEL ONLY
	bulk.insert({x_accel: data.readFloatBE(i), y_accel: data.readFloatBE(i+4), z_accel: data.readFloatBE(i+8), x_gyro: data.readFloatBE(i+12), y_gyro: data.readFloatBE(i+16), z_gyro: data.readFloatBE(i+20)});

      //col.insert(data["Sensor Data"], function(err) {
      bulk.execute(function(err) {
        if (err) {
          return cb(err);
	}
	//if (++inserted == sensorLength) {}
	if (++inserted == 1) {
           cb();
      }
      });
	}
//	}
      //col.insertOne(data["Sensor Data"][0]["Accelerometer"][0], function(err) {
      //col.insertOne(data, function(err) {
      //console.log("Insert2")
      //console.log(data)
//        if (err) {
  //        return cb(err);
    //    }

      //  cb();

      //});
    //}
    }).catch(this.handleError.bind(this));

};

proto.handleError = function(err) {

  this.emit('error', err);
  this.end();

};
