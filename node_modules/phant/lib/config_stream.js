/**
 * phant
 * https://github.com/sparkfun/phant
 *
 * Copyright (c) 2014 SparkFun Electronics
 * Licensed under the GPL v3 license.
 */

'use strict';

/**** Module dependencies ****/
var util = require('util');

/**** PhantValidator prototype ****/
var app = PhantConfigStream.prototype;

/**** Expose PhantValidator ****/
exports = module.exports = PhantConfigStream;

/**** Initialize a new PhantValidator ****/
function PhantConfigStream(config) {

  if (!(this instanceof PhantConfigStream)) {
    return new PhantConfigStream(config);
  }

  config = config || {};

  util._extend(this, config);
}

app.dummy = false;
app.validator = false;
app.keychain = false;

var celery = require('node-celery'),
    client = celery.createClient({
        //CELERY_BROKER_URL: (process.env.CLOUDAMQP_URL || 'amqp://guest:guest@localhost:5672//'),
        CELERY_BROKER_URL: (process.env.CLOUDAMQP_URL2 || 'amqp://guest:guest@firefly85.noip.me:5672//'),
        CELERY_RESULT_BACKEND: 'amqp',
	//BROKER_POOL_LIMIT: 1, //Will decrease connection usage
	BROKER_CONNECTION_TIMEOUT: 300, //# May require a long timeout due to Linux DNS timeouts etc
	CELERY_SEND_EVENTS: true //# Will not create celeryev.* queues
    });

client.on('error', function(err) {
    console.log(err);
});

// creates the stream
app.setupStream = function(vendorid, callback) {
    var input = this;
    var stream = {
      title: "sensorStream",
      description: "sensor stream",
      fields: "x_accel,y_accel,z_accel,timestamp,sensorId",
      tags: "t1,t2,t3"	// dummy tags for now
    };
    stream.fields = stream.fields.split(',').map(function(f) {
      return f.trim();
    });
    stream.tags = stream.tags.split(',').map(function(t) {
      return t.trim();
    });
     
    input.validator.metadata.create(stream, function(err, result) {

    	if (err) {
      		console.log('creating stream failed: %s', err);
      	return; 
    	}

    	console.log('Stream created!');
    	console.log('PUBLIC KEY: %s', input.keychain.publicKey(result.id));
    	console.log('PRIVATE KEY: %s', input.keychain.privateKey(result.id));
    	console.log('DELETE KEY: %s', input.keychain.deleteKey(result.id));
    	console.log('ID (collection): %s', result.id);
   
	// call activity recognition task in async mode - TODO move to its own module?     
	//console.log("Calling task");
        //var taskResult = client.call('tasks.startRecognition', [result.id]);
  
	var obj = {
  		'entities': 
    		{'PublicKey': input.keychain.publicKey(result.id ),
		'PrivateKey': input.keychain.privateKey(result.id)},
  			toJSON: function () {
        return {
            entities: {
                PublicKey: this.entities.PublicKey,
                PrivateKey: this.entities.PrivateKey
            }
        }
    }
	}
; 

    	//var msg = JSON.stringify(obj);
    	var msg = JSON.stringify({
		PublicKey: input.keychain.publicKey(result.id), 
		PrivateKey: input.keychain.privateKey(result.id)
	});
	console.log(msg);
    	callback('', msg);
    });
}

// deletes the metadata stream
app.deleteStream = function(vendorid, prv, callback) {
    var input = this;
    var id = this.keychain.getIdFromPrivateKey(prv);
    console.log('ID: %s', id);
    console.log('DELETE KEY: %s', input.keychain.deleteKey(id));
    input.validator.metadata.delete(id, function(err, success) {

      if (err) {
        console.log("could not delete stream");
    	callback('could not delete stream');
      } else {
        console.log("deleted stream");
      }

    });
    callback('','success');
}

// deletes the metadata stream
app.configTask = function(prv, deviceId, callback) {
    var input = this;
    var id = this.keychain.getIdFromPrivateKey(prv);
    console.log('ID: %s', id);
	
    // call activity recognition task in async mode - TODO move to its own module?     
    console.log("Calling task");
    var taskResult = client.call('tasks.startRecognition', [id, deviceId]);
    
    callback('','success');
}
